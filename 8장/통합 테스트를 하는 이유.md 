## 통합 테스트는 무엇인가?

단위 테스트는 다음 세 가지 요구 사항을 충족하는 테스트다.

- 단일 동작 단위를 검증하고,
- 빠르게 수행하고,
- 다른 테스트와 별도로 처리한다.

**이 중 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속한다.**

### 통합 테스트의 역할

- 통합 테스트는 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지 검증한다.
  그림
- 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 알고리즘과 도메인 모델을 다룬다.

## 테스트 피라미드

- 단위 테스트로 가능한 한 많이 비즈니스 시나리오의 예외 상황을 확인하고,
  - 대부분을 단위 테스트로 전환하면 유지비를 절감할 수 있다.
- 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룬다.
  - 중요한 통합 테스트가 비즈니스 시나리오당 하나 또는 두개 있으면 시스템 전체의 정확도를 보장할 수 있다.

그림

### 통합 테스트와 빠른 실패

- 통합 테스트에서 프로세스 외부 의존성과 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택해야 한다.
- 모든 상호 작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 확인하는데 필요한 만큼 통합 테스트를 추가로 작성해야 한다.
- 하지만 이 부분에도 예외가 있다.

  - 어떠한 예외 상황에 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 테스트할 필요가 없다.

- **버그를 빨리 나타나게 하는 것은 빠른 실패 원칙이라고 하며, 통합 테스트에서 할 수 있는 대안이다.**
  - 빠른 실패 원칙은 예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미한다.
  - 피드백 루프 단축 : 버그를 빨리 발견할 수록 더 쉽게 해결할 수 있다.
  - 지속성 상태 보호 : 버그는 애플리케이션 상태를 손상시키고 손상된 상태가 데이터베이스로 침투하면 고치기가 훨씬 어려워지기 때문에 빠른 실패를 통해 이를 방지한다.
  - 전제 조건이 실패하면 애플리케이션 상태에 대한 가정이 잘못됐으므로 빠른 실패 원칙의 예에 해당한다.

## 어떤 프로세스 외부 의존성을 직접 테스트 해야 하는가?

- 실제 프로세스 외부 의존성을 사용하거나 해당 의존성을 목으로 대체하는 방법이 있다.

### 프로세스 외부 의존성의 두가지 유형

- 관리 의존성 : 애플리케이션을 통해서만 접근할 수 있으며, 행당 의존성과의 상호 작용은 외부 환경에서 볼 수 없다.(ex. 데이터베이스)
- 비관리 의존성 : 해당 의존성과의 상호 작용을 외부에서 볼 수 있다. (ex. SMTP 서버와 메시지 버스)
- **_관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라._**
- 비관리 의존성에 대한 통신 패턴을 유지해야 하는 것은 하위 호환성을 지켜야 하기 때문인데 이 작업에는 목이 제격이다.
- 관리 의존성과 통신하는 것은 애플리케이션 뿐이므로 하위 호환성을 유지할 필요가 없다.

### 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

- 좋은 예로, 다른 애플리케이션이 접근할 수 있는 데이터베이스가 있다.
  - 시스템 데이터베이스로 시작하나 다른 시스템과 일부 통합을 위해 권한의 일부를 공개하는 것
  - 이 경우 다른 애플리케이션에서 볼 수 있는 테이블을 비관리 의존성으로 취급해야 한다.
  - 나머지 데이터베이스를 관리 의존성으로 처리하고, 상호작용이 아닌 최종 상태를 확인해야 한다.

### 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?

- **통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중해야 한다.**
- 가치가 충분하지 않은 테스트는 테스트 스위트에 있어서는 안 된다.

## 통합 테스트 예제

```
public UserController(Database database, IMessageBus messageBus)
{
    _database = database;
    _messageBus = messageBus;
}

public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    string error = user.CanChangeEmail();
    if (error != null)
        return error;

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    foreach (EmailChangedEvent ev in user.EmailChangedEvents)
    {
        _messageBus.SendEmailChangedMessage(ev.UserId, ev.NewEmail);
    }

    return "OK";
}
```

- 위 예시에서 가장 긴 주요 흐름은 기업 이메일에서 일반 이메일로 변경하는 것이다.
  - 데이터베이스에서 사용자와 회사 모두 업데이트 된다. 즉, 사용자는 유형을 변경하고 이메일도 변경하며 회사는 직원 수를 변경한다.
  - 메시지 버스로 메시지를 보낸다.

### 데이터베이스와 메시지 버스 분류하기

- 애플리케이션 데이터베이스는 어떤 시스템도 접근할 수 없으므로 관리 의존성이다.
- 메시지 버스는 다른 시스템과의 통신을 가능하게 하는 것뿐이므로 비관리 의존성이다.

### 엔드 투 엔드 테스트는 어떤가?

- 대부분의 경우 통합 테스트 범주에 관리 의존성을 포함시키고 비관리 의존성만 목으로 대체하면 통합 테스트의 보호 수준이 엔드 투 엔드 테스트와 비슷해지므로 엔드 투 엔드 테스트를 생략할 수 있다.
- 배포 후 상태 점검을 위해 한개 또는 두개 정도의 중요한 엔드 투 엔드 테스트를 작성할 수 있다.
- 그림

## 의존성 추상화를 위한 인터페이스 사용

- 단위 테스트 영역에서 가장 많이 오해하는 주제 중 하나는 인터페이스 사용이다.

### 인터페이스와 느슨한 결합

- 많은 개발자가 데이터베이스나 메시지 버스와 같은 프로세스 외부 의존성을 위해 인터페이스를 도입한다.

```
public interface IMessageBus
public class MessageBus : IMessageBus

public interface IUserRepository
public class UserRepository : IUserRepository
```

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙을 지키기 때문이다.
- **_하지만 이는 모두 오해다._**
- 단윌 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다.
- 더 기본적인 YAGNI(You aren't gonna need it)을 위반한다.
  - **YAGNI : 현재 필요하지 않은 기능에 시간을 들이지 말라는 것**
  - 기회비용 : 필요하지 않은 기능에 시간을 보낸다면 낭비다. 처음부터 실제 필요에 따라 기능을 구현하는 것이 더 유리하다.
  - 프로젝트 코드가 적을수록 좋다. 만일을 위해 코드를 작성하면 코드베이스의 소유 비용이 불필요하게 증가한다.

### 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

- 목을 사용하기 위함이다.
  - 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.
  - 따라서 이러한 **의존성을 목으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 말라.**

### 프로세스 내부 의존성을 위한 인터페이스 사용

- 프로세스 내부 의존성을 위해 인터페이스 기반인 코드가 있다면(특정 인터페이스가 항상 구현이 하나만 있다고 하면) 이는 좋지 않은 신호다.
- 도메인 클래스 간의 상호 작용을 확인해서는 안되고 이는 깨지기 쉬운테스트, 리팩터링 내성이 떨어지게 된다.

## 통합 테스트 모범 사례

- 통합 테스트를 최대한 활용하는데 도움이 되는 몇 가지 일반적인 지침이 있다.
  - 도메인 모델 경계 명시하기
  - 애플리케이션 내 계층 줄이기
  - 순환 의존성 제거하기

### 도메인 모델 경계 명시하기

- 도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘보여주고 더 잘 설명할 수 있다.
- 이러한 경계는 별도의 어셈블리 또는 네임스페이스 형태를 취할 수 있다.

### 계층 수 줄이기

- 애플리테이션에 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기 어려워진다.
- 간접 계층은 코드를 추론하는데 부정적인 영향을 미친다.
- 추상화가 지나치게 많은면 단위 테스트와 통합 테스트에도 도움이 되지 않는다.
- 가능한 한 간접 계층을 적게 사용하라. 대부분의 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스 계층, 인프라 계층만 활용하면 된다.
  그림

### 순환 의존성 제거하기

- 순환 의존성은 둘 이상의 클래스가 제대로 작동하고자 직간접적으로 서로 의존하는 것을 말한다.
- 대표적인 예는 콜백이다.

```
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        service.GenerateReport(orderId, this);

        /* other work */
    }
}

public class ReportGenerationService
{
    public void GenerateReport(
        int orderId,
        CheckOutService checkOutService)
    {
        /* calls checkOutService when generation is completed */
    }
}
```

- `CheckOutService`는 `ReportGenerationService` 인스턴스를 생성하고 해당 인스턴스에 자신을 인수로 전달한다. `ReportGenerationService`는 `CheckOutService`를 다시 호출해 보고서 생성 결과를 알려준다.
- 순환 의존성은 코드를 읽고 이해하려고 할때 알아야 할 것이 많아서 큰 부담이 된다.
- 클래스 그래프를 나눠서 동작 단위를 하나 분리하려면 인터페이스에 의존해 목으로 처리해야 하는 경우가 많은데 이는 도메인 모델을 테스트할 때 해서는 안된다.
- 순환 의존성을 제거하는 것이 좋은 방법이다.

```
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        Report report = service.GenerateReport(orderId);

        /* other work */
    }
}

public class ReportGenerationService
{
    public Report GenerateReport(int orderId)
    {
        /* ... */

        return null;
    }
}

public class Report
{
}
```

- 코드베이스에서 순환 의존성을 모두 제거하는 것은 거의 불가능하다. 하지만 최소화할 수는 있다.

### 테스트에서 다중 실행 구절 사용

- 테스트에서 두 개 이상의 준비나 실행 또는 검증 구절을 두는 것은 `코드 악취`에 해당한다.
- 이는 테스트가 여러 가지 동작 단위를 확인해서 테스트의 유지 보수성을 저해한다는 신호다.

- **각 실행을 고유의 테스트로 추출해 테스트를 나누는 것이 좋다.**
- 이 지침의 예외로, 원하는 상태로 만들기 어려운 프로세스 외부 의존성으로 작동하는 테스트가 있다.
  - 이러한 시나리오에서는 여러 동작을 하나의 테스트로 묶어서 문제가 있는 프로세스 외부 의존성에 대한 상호 작용 횟수를 줄이는 것이 유리하다.

## 로깅 기능을 테스트 하는 방법

로깅은 횡단 기능으로, 코드베이스 어느 부분에서나 필요로 할 수 있다.

- 로깅을 조금이라도 테스트 해야 하는가?

  - 애플리케이션의 동작에 대해 중요한 정보를 생성한다.
  - 그러나 로깅은 너무나 보편적이므로, 테스트 노력을 더 들일 가치가 있는지 분명하지 않다.
  - 결국 로깅은 텍스트 파일이나 데이터베이스와 같은 프로세스 외부 의존성에 사이드 이펙트를 초래한다.
  - 클라이언트가 보게 되는 경우에는 로깅은 식별가능한 동작이므로 테스트를 해야하지만 그게 아니라면 테스트를 할 가치가 없어진다.
  - **_지원 로깅은 지원 담당자나 시스템 관리자가 추적할 수 잇는 메시지를 생성한다._**
  - **_진단 로깅은 개발자가 애플리케이션 내부 상황을 파악할 수 있도록 돕는다._**

- 만약 그렇다면 어떻게 테스트 해야 하는가?
  - 애플리케이션과 로그 저장소 간의 상호 작용을 검증하려면 목을 써야 한다.
  - 변경 사항을 추적하고자 별도의 도메인 이벤트를 도입할 수 있다.
- 로깅이 얼마나 많으면 충분한가?
  - 진단 로깅을 과도하게 사용하지 않는 것이 중요하다.
  - 과도한 로깅은 코드를 혼란스럽게 한다. 특히 도메인 모델에 해당한다.
  - 핵심은 로그의 신호 대비 잡음 비율이다. 로그가 많을수록 관련 정보를 찾기가 어려워진다.
- 로거 인스턴스를 어떻게 전달할까?

  - 로거를 명시적으로 주입하는 방법(메서드 인수)은 다음과 같다. 또 다른 방법은 클래스 생성자를 통해 하는 것이다.

  ```
  public void ChangeEmail(
          string newEmail, Company company, ILogger logger)
      {
          logger.Info(
              $"Changing email for user {UserId} to {newEmail}");

          /* 생략 */
          logger.Info($"Email is changed for user {UserId}");
      }
  ```
