## 데이터베이스 테스트를 위한 전제 조건

- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 형상 관리 시스템에 데이터베이스 유지

- 데이터베이스 스키마를 일반 코드로 취급한다.
- 일반 코드와 마찬가지로 데이터베이스 스키마는 git과 같은 형상 관리 시스템에 저장하는 것이 최선이다.
- 모든 데이터베이스 스키마 업데이트를 형상 관리 시스템에 두면 원천 정보를 하나로 할 수 있고, 일반 코드 변경과 함께 데이터베이스 변경을 추적할 수 있다.

### 참조 데이터도 데이터베이스 스키마다

- 참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터
- 애플리케이션이 수정할 수 없다면 참조 데이터이다.
- 참조 데이터는 애플리케이션의 필수 사항이므로, 테이블, 뷰, 그리고 다른 데이터베이스 스키마와 함께 형상 관리 시스템에 저장해야 한다.

### 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용

- 테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용해야 한다.

### 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포

- **상태 기반 방식**

  - 개발 내내 유지 보수하는 모델 데이터베이스가 있다.
  - 배포 중에 비교 도구가 스크립트를 생성해서 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지한다.
  - 비교 도구는 모든 어려운 작업을 수행한다.
    - 운영 데이터베이스의 상태와 관계없이, 불필요한 테이블을 삭제하고 새 테이블을 생성하는 등 모든 작업을 수행한다.

- **마이그레이션 기반 방식**
  - 데이터베이스를 어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미한다.
  - 업그레이드 스크립트를 직접 작성해야 한다.

#### 상태 기반 방식보다 마이그레이션 기반 방식을 선호하라

- 상태 기반 방식은 상태를형상 관리에 저장함으로써 상태를 명시하고 비교 도구가 마이그레이션을 암묵적으로 제어할 수 있게 된다.
- 마이그레이션 기반 방식은 마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다. 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다.
- **_명시적 마이그레이션은 데이터모션(새로운 데이터베이스 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정) 문제를 해결하는데 도움이 된다._**
- 대부분의 프로젝트에서 데이터 모션이 병합 충돌보다 훨씬 중요하다.

## 데이터베이스 트랜잭션 관리

- 데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기
  - 잠재적인 모순을 피하려면 결정 유형을 두가지로 나눠야 한다.
  - 업데이트할 데이터
  - 업데이트 유지 또는 롤백 여부
- 작업 단위로 트랜잭션 업그레이드 하기
  - 작업 단위에는 비즈니스 연산의 영향을 받는 객체 목록이 있다.
  - 작업이 완료되면, 작업 단위는 데이터베이스를 변경하기 위해 해야 하는업데이트를 모두 파악하고 이러한 업데이트를 하나의 단위로 실행한다.
  - 일반 트랜잭션과 비교해서 작업 단위가 갖는 가장 큰 장점은 **업데이트 지연**이다.
  - 비즈니스 연산 종료 시점에 모든 업데이트를 실행하므로 데이터베이스 트랜 잭션의 기간을 단축하고 데이터 혼잡을 줄인다.
  - 종종 데이터베이스 호출 수를 줄이는데도 도움이 된다.

### 통합 테스트에서 데이터베이스 트랜젝션 관리하기

- 통합 테스트에서 적어도 세 개의 트랜잭션 또는 작업 단위를 사용해야 한다.(준비, 실행, 검증 구절당 하나씩)

## 테스트 데이터 생명 주기

- 공유 데이터베이스를 사용하면 통합 테스트를 서로 분리할 수 없는 문제가 생긴다. 따라서,
  - 통합 테스트를 순차적으로 실행하라.
  - 테스트 실행 간에 남은 데이터를 제거하라

### 병렬 테스트 실행과 순차적 테스트 실행

- 통합 테스트를 병렬로 실행하려면 상당한 노력이 필요하다.
- 통합 테스트의 실행 시간을 최소화해야 하는 경우가 아니라면 컨테이너를 사용하지 않는 것이 좋다.
- 데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 더 실용적이다.

### 테스트 실행 간 데이터 정리

- 각 테스트 전에 데이터베이스 백업 복원하기

  - 데이터 정리 문제를 해결할 수 있으나 느리다.

- 테스트 종료 시점에 데이터 정리하기

  - 빠르지만 정리 단계를 건너뛰기 쉽다.

- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기

  - 작업 단위를 재사용할 때 추가 트랜잭션으로 인해 운영 환경과 다른 설정이 생성된다.

- **테스트 시작 시점에 데이터 정리하기**
  - 빠르게 작동하고 일관성이 없는 동작을 일으키지 않으며, 정리 단계를 실수로 건너뛰지 않는다.

## 테스트 구절에서 코드 재사용하기

- 필수가 아닌 부분을 비공개 메서드 또는 헬퍼 클래스로 추출해 테스트를 단축하는 것이 좋다.
  - 준비 구절에서는 테스트 데이터 빌더 대신 오브젝트 마더를 선택
  - 실행 구절에서는 데코레이터 메서드를 작성
  - 검증 구절에서는 플루언트 인터페이스 도입

## 읽기 테스트를 해야하는가?

- 읽기 테스트 임계치는 쓰기 테스트 임계치보다 높아야 한다.
- 가장 복잡하거나 중요한 읽기 작업만 테스트하고 나머지는 무시해도 좋다.

## 리포지토리를 테스트 해야 하는가?

- 리포지토리 테스트는 회귀 방지에 대한 이득이 너무 적은 데 반해 유지비가 너무 높다.
- 포괄적인 통합 테스트 스위트로 취급하는 것이 좋다.
