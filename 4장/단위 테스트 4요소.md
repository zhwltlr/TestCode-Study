좋은 단위 테스트에는 네가지 특성이 있다.

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

## 첫번째 요소 : 회귀 방지

여기서 회귀란, 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우를 말한다.
회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.

- 테스트 중에 실행되는 코드의 양
  - 실행되는 코드가 많을수록 회귀가 나타날 가능성이 높다.
  - 코드가 생성하는 결과가 유효한지도 확인해야 한다.
- 코드 복잡도
- 코드의 도메인 유의성

반면에 단순한 코드를 테스트 하는 것은 가치가 거의 없다.
게다가 코드 외에 작성하지 않은 코드(ex.라이브러리)도 중요하다. 최상의 보호를 위해서는 테스트가 해당 라이브러리, 외부 시스템등을 테스트 범주에 포함시켜서 의존성에 대해 검증이 올바른지 확인한다.

## 두번째 요소 : 리팩터링 내성

- 테스트를 빨간색(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도
- 리팩터링을 하다보면 실제로 기능이 의도한 대로 작동하지만 테스트는 실패를 나타내는 경우가 있는데 이런 상황을 **_거짓 양성(false positive)_**라고 한다.
- 테스트에서 얼마나 많이 거짓 양성이 발생하는지가 리팩터링 내성 지표 평가 기준이며 낮을수록 좋다.

- 거짓 양성이 중요한 이유
  - 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력이 희석되어 기능이 고장나도 운영 환경에 들어가게 된다.
  - 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 이는 회귀를 피하고자 코드 변경을 최소화 하는 악순환이 된다.

### 무엇이 거짓 양성의 원인인가?

- 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합할수록 허위 정보가 더 많이 생긴다.
- **거짓 양성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다. 즉, _SUT가 제공하는 최종 결과, 동작을 검증하는지 확인해야 한다._**

  ```
  public class MessageRenderer : IRenderer
  {
      public IReadOnlyList<IRenderer> SubRenderers { get; }

      public MessageRenderer()
      {
          SubRenderers = new List<IRenderer>
          {
              new HeaderRenderer(),
              new BodyRenderer(),
              new FooterRenderer()
          };
      }

      public string Render(Message message)
      {
          return SubRenderers
              .Select(x => x.Render(message))
              .Aggregate("", (str1, str2) => str1 + str2);
      }
  }

  // MessageRenderer 구조가 올바른지 확인
  [Fact]
  public void MessageRenderer_uses_correct_sub_renderers()
  {
      var sut = new MessageRenderer();

      IReadOnlyList<IRenderer> renderers = sut.SubRenderers;

      Assert.Equal(3, renderers.Count);
      Assert.IsAssignableFrom<HeaderRenderer>(renderers[0]);
      Assert.IsAssignableFrom<BodyRenderer>(renderers[1]);
      Assert.IsAssignableFrom<FooterRenderer>(renderers[2]);
  }
  ```

- `MessageRenderer` 클래스에 여러 하위 렌더링 클래스가 있고 메세지의 일부에 대한 실제 작업을 위임한다.
- 아래의 테스트는 하위 렌더링 클래스가 예상하는 모든 유형이고 올바른 순서로 나타나는지 여부를 확인한다.
- 이때 하위 렌더링 클래스의 구성을 변경해도 동일한 동작을 할 수 있다. 최종 결과가 바뀌지 않을지라도, 테스트는 실패로 변할 것이다. SUT의 구현 세부 사항과 결합했기 때문이다.
  그림

- **SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다.**
  - 단점: 회귀 발생 시 조기 경고를 제공하지 않는다. 그리고 버그를 찾을 때 테스트가 어느 방향인지 알려줄 수 없다.

### 구현 세부 사항 대신 최종 결과를 목표로 하기

- 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.

  ```
  [Fact]
  public void Rendering_a_message()
  {
      var sut = new MessageRenderer();
      var message = new Message
      {
          Header = "h",
          Body = "b",
          Footer = "f"
      };

      string html = sut.Render(message);

      Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);
  }
  ```

- 위 테스트는 `MessageRenderer`를 블랙박스로 취급하고 식별할 수 있는 동작에만 신경을 써 리팩터링 내성이 부쩍 늘었다.
  그림

## 회귀 방지와 리팩터링 내성 간의 본질적인 관계

둘 다 정반대의 관점에서도 테스트 스위트의 정확도에 기여한다.
따라서 둘을 모두 고려하며 테스트 스위트 정확도를 높이는 것은 쉽지 않다.

### 테스트 정확도 극대화

그림

- 테스트에서 오류가 발생하지 않으면 문제가 된다. 이는 '거짓 음성'이다.
- 기능은 올바르지만 테스트가 여전히 실패로 표시되는 상황은 '거짓 양성'이다.

### 거짓 양성과 거짓 음성의 중요성

- 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미치기 시작한다.
- 그림
- 리팩터링이 점점 더 필요해짐에 따라 테스트에서 리팩터링 내성도 점점 더 중요해진다.
- 이때 존재하지 않는 버그에 대해 경고를 계속 받게 되면 테스트는 신뢰를 잃는다.
- 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다.

## 세번째 요소와 네번째 요소 : 빠른 피드백과 유지 보수성

- 빠른 피드백

  - 테스트 속도가 빠를수록 테스트 스위트에서 더 맣은 테스트를 수행할 수 있고 더 자주 실행할 수 있다
  - 테스트가 빠르게 실행되면 코드에 결함이 생기자마자 경고하기 시작할 정도로 피드백 루프를 대폭 줄여서, 수정하는 비용을 거의 0까지 줄일 수 있다.

- 유지 보수성
  - 테스트가 얼마나 이해하기 어려운가?
    - 테스트를 작성할 때 절차를 생략하지 말아야 한다.
  - 테스트가 얼마나 실행하기 어려운가?
    - 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 시간을 들여야 한다.

## 이상적인 테스트

- 회귀 방지 / 리팩터링 내성 / 빠른 피드백 / 유지 보수성 모든 특성을 곱하면 가치가 결정된다.
- 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨야 한다.
- 소수의 가치 있는 테스트는 다수의 평범한 테스트보다 더 효과적이다.
- **회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이다** 따라서 세가지 특성 모두 최대로 하는 것은 불가능하다.
- 따라서 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다.
- 극단적인 사례1 : 엔드 투 엔드 테스트는 회귀 방지와 리팩터링 내성에 우수하지만 빠른 피드백이 불가하다.
- 극단적인 사례2 : 간단한 테스트는 빠른 피드백과 리팩터링 내성에 우수하지만 회귀 방지가 없다.
- 극단적인 사례3 : 거짓 양성이 많은 테스트 즉 깨지기 쉬운 테스트는 파른 피드백과 회귀 방지에 우수하지만 리팩터링 내성은 없다.
  그림
- **_리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야한다._** 리팩터링 내성은 있거나 없거나 둘 중 하나기에 포기할 수 없다.
  - 테스트 스위트를 탄탄하게 만들려면 테스트의 불안정성을 제거하는 것이 최우선 과제이다.

### 대중적인 테스트 자동화

- 테스트 피라미드 : 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 일정한 비율을 말하며, 엔드 투 엔드 테스트가 가장 적고, 단위 테스트가 가장 많다.

- 블랙박스 테스트는 시스템 내부 구조를 몰라도 시스템 기능을 검사할 수 있는 소프트웨어 테스트 방법이다.
  - 애플리케이션이 어떻게 해야 하는지가 아니라 무엇을 해야 하는지 주심으로 구축된다.
- 화이트박스 테스트는 애플리케이션의 내부 작업을 검증하는 방식이다.
  - 소스 코드를 분석하면 많은 오류를 발견할 수 있다는 장점이 있으나 테스트 대상 코드의 특정 구현과 결합돼 있기 때문에 깨지기 쉽다.
- 리팩터링 내성을 놓칠 수 없기 때문에 블랙박스 테스트를 기본으로 선택하라

  - 모든 테스트가 시스템을 블랙박스로 보게 만들고 문제 영역에 의미 있는 동작을 확인하라

- **테스트를 작성할 때는 블랙박스 테스트가 바람직하지만, 테스트를 분석할 때는 화이트박스 방법을 사용할 수 있다.**
  - 코드 커버리지 도구를 사용해서 어떤 코드 분기를 실행하지 않았는지 확인한 다음 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트 하라
