좋은 단위 테스트에는 네가지 특성이 있다.

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

## 첫번째 요소 : 회귀 방지

여기서 회귀란, 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우를 말한다.
회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.

- 테스트 중에 실행되는 코드의 양
  - 실행되는 코드가 많을수록 회귀가 나타날 가능성이 높다.
  - 코드가 생성하는 결과가 유효한지도 확인해야 한다.
- 코드 복잡도
- 코드의 도메인 유의성

반면에 단순한 코드를 테스트 하는 것은 가치가 거의 없다.
게다가 코드 외에 작성하지 않은 코드(ex.라이브러리)도 중요하다. 최상의 보호를 위해서는 테스트가 해당 라이브러리, 외부 시스템등을 테스트 범주에 포함시켜서 의존성에 대해 검증이 올바른지 확인한다.

## 두번째 요소 : 리팩터링 내성

- 테스트를 빨간색(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도
- 리팩터링을 하다보면 실제로 기능이 의도한 대로 작동하지만 테스트는 실패를 나타내는 경우가 있는데 이런 상황을 **_거짓 양성(false positive)_**라고 한다.
- 테스트에서 얼마나 많이 거짓 양성이 발생하는지가 리팩터링 내성 지표 평가 기준이며 낮을수록 좋다.

- 거짓 양성이 중요한 이유
  - 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력이 희석되어 기능이 고장나도 운영 환경에 들어가게 된다.
  - 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 이는 회귀를 피하고자 코드 변경을 최소화 하는 악순환이 된다.

### 무엇이 거짓 양성의 원인인가?

- 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합할수록 허위 정보가 더 많이 생긴다.
- **거짓 양성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다. 즉, _SUT가 제공하는 최종 결과, 동작을 검증하는지 확인해야 한다._**

```
public class MessageRenderer : IRenderer
{
    public IReadOnlyList<IRenderer> SubRenderers { get; }

    public MessageRenderer()
    {
        SubRenderers = new List<IRenderer>
        {
            new HeaderRenderer(),
            new BodyRenderer(),
            new FooterRenderer()
        };
    }

    public string Render(Message message)
    {
        return SubRenderers
            .Select(x => x.Render(message))
            .Aggregate("", (str1, str2) => str1 + str2);
    }
}

// MessageRenderer 구조가 올바른지 확인
[Fact]
public void MessageRenderer_uses_correct_sub_renderers()
{
    var sut = new MessageRenderer();

    IReadOnlyList<IRenderer> renderers = sut.SubRenderers;

    Assert.Equal(3, renderers.Count);
    Assert.IsAssignableFrom<HeaderRenderer>(renderers[0]);
    Assert.IsAssignableFrom<BodyRenderer>(renderers[1]);
    Assert.IsAssignableFrom<FooterRenderer>(renderers[2]);
}
```

- `MessageRenderer` 클래스에 여러 하위 렌더링 클래스가 있고 메세지의 일부에 대한 실제 작업을 위임한다.
- 아래의 테스트는 하위 렌더링 클래스가 예상하는 모든 유형이고 올바른 순서로 나타나는지 여부를 확인한다.
- 이때 하위 렌더링 클래스의 구성을 변경해도 동일한 동작을 할 수 있다. 최종 결과가 바뀌지 않을지라도, 테스트는 실패로 변할 것이다. SUT의 구현 세부 사항과 결합했기 때문이다.
  그림

- **SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다.**
  - 단점: 회귀 발생 시 조기 경고를 제공하지 않는다. 그리고 버그를 찾을 때 테스트가 어느 방향인지 알려줄 수 없다.

### 구현 세부 사항 대신 최종 결과를 목표로 하기

- 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.

```
[Fact]
public void Rendering_a_message()
{
    var sut = new MessageRenderer();
    var message = new Message
    {
        Header = "h",
        Body = "b",
        Footer = "f"
    };

    string html = sut.Render(message);

    Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);
}
```

- 위 테스트는 `MessageRenderer`를 블랙박스로 취급하고 식별할 수 있는 동작에만 신경을 써 리팩터링 내성이 부쩍 늘었다.
  그림

## 회귀 방지와 리팩터링 내성 간의 본질적인 관계

둘 다 정반대의 관점에서도 테스트 스위트의 정확도에 기여한다.

### 테스트 정확도 극대화

그림

- 테스트에서 오류가 발생하지 않으면 문제가 된다. 이는 '거짓 음성'이다.
- 기능은 올바르지만 테스트가 여전히 실패로 표시되는 상황은 '거짓 양성'이다.

### 거짓 양성과 거짓 음성의 중요성
